from fastapi import FastAPI, Depends, HTTPException, status
from pydantic import BaseModel
from typing import List, Dict, Any
import logging

from schemas.models import (
    GetVibeReportResponse, VibeReportOutput,
    CloneBrandVoiceRequest, CloneBrandVoiceResponse, BrandVoiceOutput,
    GetSmartReceiptRequest, GetSmartReceiptResponse, SmartReceiptOutput
)
from services.ai_service import AIService
from services.data_engine import DataEngine
from services.image_service import ImageService

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

app = FastAPI(
    title="Optic Pulse API",
    description="A modular AI-retail suite for OptCulture.",
    version="0.1.0"
)

# Dependency injection for services
def get_ai_service() -> AIService:
    return AIService()

def get_data_engine() -> DataEngine:
    # DataEngine requires explicit closing of connection.
    # For FastAPI, this means managing its lifecycle.
    # A simpler approach for now is to create it per request, or use a lifespan event.
    # For this example, let's instantiate it per request.
    return DataEngine()

def get_image_service() -> ImageService:
    return ImageService()

@app.get("/")
async def root():
    return {"message": "Welcome to Optic Pulse API"}

@app.post("/vibe-report", response_model=GetVibeReportResponse, status_code=status.HTTP_200_OK)
async def generate_vibe_report(
    user_id: str, # Assuming user_id is passed as a query parameter or header for now
    ai_service: AIService = Depends(get_ai_service),
    data_engine: DataEngine = Depends(get_data_engine),
    image_service: ImageService = Depends(get_image_service)
):
    """
    Generates a Vibe Report for a given user, including an image card.
    """
    logging.info(f"Received request for Vibe Report for user_id: {user_id}")
    try:
        # 1. Fetch transaction history
        # For a real application, you'd filter by user_id
        # For now, let's simulate a summary based on general data or a placeholder.
        # In a real scenario, data_engine would provide user-specific aggregated summary.
        # Placeholder for transaction summary (needs to be generated by data_engine ideally)
        
        # A more realistic approach would be:
        # transaction_lf = data_engine.get_transaction_history_lazyframe().filter(pl.col("customer_id") == user_id)
        # transaction_summary_data = transaction_lf.collect().to_dicts() # or some aggregation
        # For now, let's create a dummy summary
        transaction_summary = "Placeholder transaction summary for user " + user_id + \
                              ". User frequently buys eco-friendly products and organic food."

        # 2. Get Vibe Report from AI
        vibe_report_output: VibeReportOutput = ai_service.get_vibe_report(transaction_summary)

        # 3. Generate Vibe Card Image
        # Use a subset of stats for the image for clarity
        stats_for_card = {
            "Persona": vibe_report_output.shopping_persona,
            "Spend": vibe_report_output.key_purchase_metrics.get("total_spend", "N/A"),
            "Category": vibe_report_output.key_purchase_metrics.get("most_bought_category", "N/A")
        }
        image_path = image_service.generate_vibe_card(
            username=user_id,
            vibe_label=vibe_report_output.shopping_persona,
            stats=stats_for_card
        )
        
        # In a production scenario, you might return a URL to the image, not local path
        vibe_report_output.key_behavioral_metrics["vibe_card_image"] = image_path

        return GetVibeReportResponse(user_id=user_id, report=vibe_report_output)
    except HTTPException:
        raise # Re-raise HTTP exceptions
    except Exception as e:
        logging.error(f"Error generating Vibe Report for user {user_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate Vibe Report: {e}"
        )
    finally:
        data_engine.close_connection() # Close DuckDB connection

@app.post("/brand-voice", response_model=CloneBrandVoiceResponse, status_code=status.HTTP_200_OK)
async def clone_brand_voice_api(
    request: CloneBrandVoiceRequest,
    ai_service: AIService = Depends(get_ai_service)
):
    """
    Clones a brand's voice based on provided campaign texts and generates new content.
    """
    logging.info(f"Received request for Brand Voice Cloning for brand_id: {request.brand_id}")
    try:
        brand_voice_output: BrandVoiceOutput = ai_service.clone_brand_voice(request.campaign_texts)
        return CloneBrandVoiceResponse(brand_id=request.brand_id, cloned_voice=brand_voice_output)
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error cloning brand voice for brand {request.brand_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to clone brand voice: {e}"
        )

@app.post("/smart-receipt", response_model=GetSmartReceiptResponse, status_code=status.HTTP_200_OK)
async def get_smart_receipt(
    request: GetSmartReceiptRequest,
    ai_service: AIService = Depends(get_ai_service),
    data_engine: DataEngine = Depends(get_data_engine)
):
    """
    Generates smart receipt recommendations based on basket items and purchase patterns.
    """
    logging.info(f"Received request for Smart Receipt for customer_id: {request.customer_id}")
    try:
        # In a real scenario, past_purchase_patterns might be fetched/aggregated by data_engine
        # For now, we use the patterns directly from the request.
        
        smart_receipt_output: SmartReceiptOutput = ai_service.get_smart_receipt_recommendations(
            request.current_basket_items,
            request.past_purchase_patterns
        )
        return GetSmartReceiptResponse(customer_id=request.customer_id, receipt_suggestions=smart_receipt_output)
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error generating Smart Receipt for customer {request.customer_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate Smart Receipt: {e}"
        )
    finally:
        data_engine.close_connection() # Close DuckDB connection

# To run this file:
# 1. cd opt-pulse
# 2. uvicorn main:app --reload
